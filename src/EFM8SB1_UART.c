//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include <SI_EFM8SB1_Register_Enums.h>
#include "EFM8SB1_UART.h"
#include "Typedef.h"

//-----------------------------------------------------------------------------
// Global CONSTANTS
//-----------------------------------------------------------------------------
#define _UART_BUFFERSIZE        8

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------
U8 TX_Ready;
U8 TX_Len;
U8 Tx_First;
U8 *Tx_Ptr;

U8 UART_Buffer[ _UART_BUFFERSIZE ];
U8 UART_Buffer_Size;
U8 UART_Input_First = 0;
U8 UART_Output_First = 0;

//-----------------------------------------------------------------------------
// UART0_ISR
//-----------------------------------------------------------------------------
// UART0 ISR Content goes here. Remember to clear flag bits:
// SCON0::RI (Receive Interrupt Flag)
// SCON0::TI (Transmit Interrupt Flag)
//-----------------------------------------------------------------------------
SI_INTERRUPT( UART0_ISR, UART0_IRQn )
{
	if( SCON0_RI == 1 )
	{
		if( UART_Buffer_Size == 0 )
		{
			// If new word is entered
			UART_Input_First = 0;
		}

		SCON0_RI = 0;                       			// Clear interrupt flag

		if( UART_Buffer_Size < _UART_BUFFERSIZE )
		{
			UART_Buffer[ UART_Input_First ] = SBUF0; 	// Store in array

			UART_Buffer_Size++;             			// Update array's size

			UART_Input_First++;             			// Update counter
		}
		else
		{
			//UART_Buffer Overflow
		}
	}

	if( SCON0_TI == 1 )                   	// Check if transmit flag is set
	{
		SCON0_TI = 0;                       // Clear interrupt flag

		if( TX_Len )
		{
			SBUF0 = *(Tx_Ptr + Tx_First);

			TX_Len--;

			Tx_First++;

		}
		else if( TX_Len == 0 )
		{

			TX_Ready = 1;
		}
	}
}

U8 UartRead( U8 *buf, U16 length )
{
	U8 result = 0;

	if( UART_Buffer_Size >= _UART_BUFFERSIZE )
	{
		// UART_Buffer_Size Overflow
		// Debug
		NOP();
	}

	while( length )
	{
		if( UART_Buffer_Size != 0 )
		{
			if( UART_Buffer_Size == UART_Input_First )
			{
				UART_Output_First = 0;
			}

			// Store a character in the variable byte
			*(buf + result) = UART_Buffer[ UART_Output_First ];

			UART_Output_First++;            // Update counter
			UART_Buffer_Size--;             // Decrease array size
			result++;
			length--;
		}
		else
			break;
	}

	return result;
}

void UartWrite( const U8 *data_ptr, U16 length )
{
	if( length == 0 )
		return;

	while( TX_Ready == 0 );

	TX_Ready = 0;
	TX_Len = length;
	Tx_First = 0;
	Tx_Ptr = data_ptr;

	SCON0_TI = 1;
}
